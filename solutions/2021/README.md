## Learnings/Study Notes:

- Inclusion-exclusion principle (Day 22): [Reddit user comment by u/ai_prof](https://www.reddit.com/r/adventofcode/comments/rlxhmg/comment/hqxczc4/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)
- Sweep line algorithm (Day 22): [Reddit user comment by u/NeilNjae](https://www.reddit.com/r/adventofcode/comments/rlxhmg/comment/hqfephy/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)

## Day 19

- Definitely hard for me, I was initially trying the rotations via swapping of x, y, z components and changing signs, which did work in terms of getting the 24 orientations and finding the coordinates of the other scanners relative to scanner 0 if it had 12 beacons in common. However I was having trouble cascading rotations, so I moved to creating the rotation matrices in numpy
- I was storing the relative coordinates of the scanners in a dictionary `{scanner1: (scanner2, (offset), rotation_matrix}` if `scanner1` coordinates are already known while `scanner2` isn't yet. However, if its the reverse (`scanner2` relative coordinates known, `scanner1` not yet) I can't seem to make it work for the input. After taking more than a day, waking up from a nap, and a cup of coffee I tried instead storing the reverse as well so that I don't need to handle the 2nd case, and it immediately worked. This means that there are double the calculations needed for `{scanner1: (scanner2, ...)}` and `{scanner2: (scanner1, ...)}` but since its fast enough (a few seconds for the actual input) I didn't bother optimizing it anymore.

## Day 22

- Conceptually straightforward and the main problem is finding an efficient solution as brute-force would be too complex in time and memory.
- My main idea was to record all possible x, y, z min and max boundaries from each step and store on/off states in a dictionary with keys `((x_min, x_max), (y_min, y_max), (z_min, z_max))`. This should take a few minutes to finish, however with the actual input the dictionary becomes too large and the program runs out of memory on my machine with 16GB RAM. The total boundaries for each axis is around 800 so even with my inefficient implementation that also stores the boundaries themseves, I initially did not expect it to take up that much space.
- A more efficient approach would probably be finding the intersections of each step with the existing cuboids with already known states after each step. This doesn't store all possible boundaries like the above, which blew up the dictionary. However I was expecting I'd have a problem with actually programming that so I didn't bother.
- I tried but failed to make a 2nd approach work, which involved checking for which steps had actual overlaps with other steps, and the idea was to precompute regions with no/less overlaps before moving on to regions with more overlaps across more steps. I abandoned the idea after not being able to make it work but it should still be a viable solution that would probably be more efficient in time and space than my 1st approach.
- I went back with the original approach to try to improve the space complexity instead. Changing the dictionary to a set improves the memory efficiency just a little bit so it still doesn't finish. So to trade off space for time, I divided the whole space into smaller regions so it can compute each of them without running out of memory. After dividing each axis by 10 for a total of 1000 regions, the program did finish after several minutes.
- My implementation was highly inefficient so even with the same approach I think the runtime could be improved significantly. I was doing a lot of repetitive operations and some inefficient data structures that could probably be improved, such as always computing the boundaries in `boundaries_list`, which could instead be precomputed for the whole space and just divided for each region, and the repeated removal of off states from the set `cubes_set`, which represent the set of regions that are on.
- Another approach I was also thinking of but I wasn't able to program was similar to the 2nd approach I tried regarding overlaps. A set theoretic approach typically applied to Venn diagram examples of immediately computing the on states, subtracting if there were on to off states, and also subtracting any duplicate on states due to overlaps would work. After solving it with my approach and browsing Reddit, a user commented that they solved it with this approach in Python that runs in 11s on my machine so hopefully I get some time to study his code: [Reddit user comment by u/ai_prof](https://www.reddit.com/r/adventofcode/comments/rlxhmg/comment/hqxczc4/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)

## Day 23

- Overall this was an easy problem and the programming part itself was what took some time to do. I did a DFS using a recursive function with memoization. Each call iterates through all amphipods and for each amphipod finds 3 possible conditions to recursively do all possible moves:
    - If its already in its correct room: It won't move, and if this applies to all the amphipods then this is the base case
    - If its in a hallway and is able to move to its correct room: Move to the room
    - If its in an incorrect room and is able to get out: Move to the hallway
- I do BFS to check if it has a path from its current location to its next location
- I hardcoded the 2 room slots I called `outer` and `inner` in part 1 and didn't generalize to arbitrary number of slots, so in part 2 its still hardcoded and just extended to 4 room slots I called `outer2`, `outer1`, `inner2`, and `inner1`
- Initial bug that took me some time to debug was that memoization wasn't working because the tuple input arguments to my recursive function isn't sorted, so after simply sorting them on each call memoization immediately worked with an off-by-2 value in the example. I actually solved Part 1 by considering this off-by-2 error, which was a quick fix while working on Part 2. The missing 2 energy was due to not considering if there is a valid path between an amphipod in a hallway towards its valid room. Simply adding BFS to check the path first resolved the bug.
- My solution takes around 10s for both parts with examples and 6s without examples. A low-hanging fruit optimization on my current approach is to have an amphipod go directly to a valid room if its able to instead of the extra step of moving to a hallway first. This should prune a lot more possible movements, though I'll have to check how much it saves.
- The subreddit's solution threads mention a lot of Dijkstra's and A\* star search solutions. My DFS approach could be converted to a BFS with the same conditions, and won't need another inner loop for BFS as I did, plus inherently being able to record the final optimal path, so I'm curious how much speed up it would be.

## Day 24

- Reverse engineering problem that turned out to be easy due to the instruction pattern, but would have been very difficult if the patterns weren't consistent across all digits.
- Before I proceeded with analyzing the instructions, I went ahead and initially tried a brute force approach via DFS with recursion and memoization which didn't work out. Even though there are 9^14 possible numbers, I assumed that memoization would take care of the large search space but after looking into the problem some more, I'd guess that there aren't enough caching happening since the input space of the digit number, current variable values, and remaining instructions are still too large. I'm curious if others were able to make a brute-force memoized solution in Python run fast.
- After seeing that my memoization approach won't work, I reverse engineered the instructions starting from digit 14. I manually checked digits 14, 13, and 12 instructions and wrote some initial hardcoded loops for backtracking up to digit 12 to analyze the inputs some more. Each digit instructions is only dependent on the the previous digit's `z` variable I called `prev_z` and the current digit `w`. So the current digit's `z` can be expressed as `z = int(prev_z/A)*(25*x + 1) + (w + C)*x` where `x = [(prev_z % 26) + B] != w` and `A`, `B`, and `C` are parameters from the instructions.
- I then wrote some code to check whether all digit instructions follow the same structure/pattern and fortunately they do, so I extracted the parameters for each digit to automatically get all `z` expressions. Then I backtracked and recorded the required `z` values for digits 13 to 1, across possible `w` digit values. I didn't record the `w` values since some of the `z` values may not fully propagate back to digit 1 so there was no point in recording `w` which would complicate the data structure, slow down the backtracking even more, and because I was anticipating that the feedforward path of recomputing `w` would be much faster than the backtracking which was true.
- My initial code only used `prev_z in range(-26, 27)` since I forgot about `prev_z` being divided by `A` and only remembered `prev_z % 26`. This backtracked only up to digit 4, so I first looked at the negative values since I remembered that Python's modulo operator worked differently for negative values compared to other languages. Looking back at the problem, it explicitly said that negative values of `a` aren't used so I removed the negative part, and extended the range until it was able to backtrack up to digit 1. I ended up using `range(0, 1000000)`, which also showed that at digit 1 the `prev_z` should just be 0 as expected since its the initial value of `z` before running any instruction.
- Once the required `prev_z` values have been computed, I did DFS with recursion where it sweeps `w` per digit, with the base case being digit 14's `z = 0`. Once encountered, the function exits early so that the first valid model number is the maximum if `w` was sweeped with `range(9, 0, -1)`. As expected, the DFS part is much faster than the backtracking part. I still used the parametrized `z` expressions instead of actually running the instructions.
- Moving from Part 2 to Part 1 was very easy since the DFS was already greedy, so I just had to reverse the sweep range from `range(9, 0, -1)` to `range(1, 9)` and it would give the minimum instead of maximum. There was also no need to redo the backtracking because it backtracks across all possible `w` digits anyway. I was initially anticipating something like extending the model number to 27 or 28 digits by needing to run a digit's instructions twice or incorporating some jumps/loops. It should still be solvable with the same approach if that was the case, though the backtracking of `z` values would take longer.
- After solving, I tried a quick optimization of decreasing the `prev_z` sweep range from 1000000 to 400000 during backtracking since for my input the max possible `prev_z` was over 314022, and this reduced the runtime from around 28s to 12s. A dynamic value for the range depending on the digit's `A` parameter would probably be even faster.

## Day 25

- I originally solved this using a single dictionary `grid_dict` that stores the whole grid states, including the spaces. In each step, I did a deep copy to an intermediate dictionary `new_grid_dict` and iterate through all the rows and columns twice for the east-facing and south-facing sea cucumbers. This is inefficient but solves my input in 18 seconds.
- After the solve, I quickly refactored to optimize the runtime down to 0.6s by using 2 sets to store the east- and south-facing sea cucumbers to `eastward_set` and `southward_set` respectively, and not storing the spaces anymore. Then in each step instead of iterating across all rows and columns twice, we just iterate through the sets themselves so we don't need to look through unnecessary coordinates, and instead of deep copying a dictionary we just construct new sets and shallow copy them back to `eastward_set` and `southward_set` once the step ends.
